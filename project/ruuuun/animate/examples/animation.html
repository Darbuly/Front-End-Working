<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>UIM特效开发</title>
	<meta name="renderer" content="webkit">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<script src="../../../../lib/jquery/jquery.min.js"></script>

	<script src="../../../../lib/rui/rui.js"></script>

</head>


<style>
	* {
		padding: 0;
		margin: 0;
	}

	body {
		background-color: rgb(34, 34, 34);
	}

	#aniAttrTmp {
		display: none;
	}

	.ani-ctrl-wrap {
		padding: 10px 5px;
	}

	.ani-select-wrap {
		display: flex;
	}

	.ani-add-btn {
		width: 100%;
		height: 56px;
	}

	.ani-item {
		width: 80px;
		height: 80px;
		background-color: rgb(34, 34, 34);
		color: #fff;
		line-height: 80px;
		text-align: center;
		margin-right: 5px;
	}

	.effect-selected {
		border: 1px solid red;
	}

	.work {
		width: 100%;
		display: flex;
	}

	.show-animate {
		width: 70%;
		height: 100vh;
		background-color: #eee;
	}
</style>

<body>
	<div class="work">

		<div class="show-animate">

			<span id="target">测试动画</span>


		</div>

		<div id="aniAttrWrap" class="ani-attr-wrap">
		</div>

	</div>





	<div id="aniAttrTmp" style="display: none">
		<div style="width: 30%;">


			<button class="ani-add-btn" type="button" @click="addAniItem">添加特效</button>
			<el-collapse v-model="activeNames">
				<el-collapse-item v-for="(aItem,aIndex) in anitItemList"
					:title="'特效'+aItem.id+' ('+aniEffectList[aItem.use_effect_id-1].name+')'"
					:name="aItem.id">

					<div class="ani-ctrl-wrap">

						<div class="ani-select-wrap">
							<div v-for="(eItem,eIndex) in aniEffectList"
								@click="selectEffect(aItem.id,eItem.id)"
								:class="{'ani-item':true,'effect-selected':aItem.use_effect_id==eItem.id}">
								{{eItem.name}}</div>
						</div>

						<div class="ani-ctrl">
							<span>持续时间:</span>
							<el-input-number v-model="aItem.duration"
								@change="handleDurationChange" :min="1" :max="10"
								label="描述文字">
							</el-input-number>

							<br>
							<span>延迟时间:</span>
							<el-input-number v-model="aItem.delay"
								@change="handleDelayChange" :min="0" :max="10"
								label="描述文字"></el-input-number>
							<br>
							<span>循环次数:</span>
							<el-input-number v-model="aItem.loop" @change="handleLoopChange"
								:min="1" :max="10" label="描述文字"></el-input-number>
							<br>
							<span>循环间隔:</span>
							<el-input-number v-model="aItem.loopInterval"
								@change="handleLoopIntervalChange" :min="0" :max="10"
								label="描述文字">
							</el-input-number>
						</div>


					</div>


				</el-collapse-item>
			</el-collapse>
		</div>
	</div>


	<script src="../animate-lib/velocity.js"></script>
	<script>

		var element = document.getElementById('target');

		rui.use(['collapse', 'input-number'], function () {

			var tmpStr = $("#aniAttrTmp")[0].innerHTML;
			var collapse = rui.collapse;
			collapse.render({
				el: "#aniAttrWrap",
				template: tmpStr,
				data: {
					num: 1,
					activeNames: '1',
					aniEffectList: [
						// {
						// 	id: 1,
						// 	name: "向上淡入",
						// },
						// {
						// 	id: 2,
						// 	name: "从小到大",
						// },
						{
							id: 1,
							name: "字体变大",
						},
						{
							id: 2,
							name: "淡出",
						}
					],
					anitItemList: [{
						id: 1,
						use_effect_id: 1,
						duration: 1,
						delay: 0,
						loop: 1,
						loopInterval: 0
					}]
				},
				methods: {
					addAniItem: function () {
						console.log('addAniItem');

						const lastItem = this.anitItemList[this.anitItemList.length - 1];

						const option = {
							id: lastItem.id + 1,
							use_effect_id: 1,
							duration: 1,
							delay: 0,
							loop: 1,
							loopInterval: 0
						}

						this.anitItemList.push(option)

						this.exposeData();

					},
					selectEffect: function (ani_id, effect_id) {
						console.log('effect_id', effect_id);

						for (let i = 0; i < this.anitItemList.length; i++) {
							const anitItem = this.anitItemList[i];

							if (anitItem.id == ani_id) {
								this.anitItemList[i].use_effect_id = effect_id;
							}

						}

						this.exposeData();
					},
					handleDurationChange: function (e) {
						console.log('handleDurationChange', e);
						this.exposeData();
					},
					handleDelayChange: function (e) {
						console.log('handleDelayChange', e);
						this.exposeData();
					},
					handleLoopChange: function (e) {
						console.log('handleLoopChange', e);
						this.exposeData();
					},
					handleLoopIntervalChange: function (e) {
						console.log('handleLoopIntervalChange', e);
						this.exposeData();
					},
					exposeData: function () {

						let res = JSON.parse(JSON.stringify(this.anitItemList));
						let res2 = [];

						res.map(function (rItem) {
							res2.push({
								el: 'target',
								...rItem,
								fillMode: 'backwards'//backwards forwards
							})
						})

						play(res2, element);
					}
				}
			})

		});
	</script>


	<script src="../animate-lib/animate-def.js"></script>


	<script>
		var def_data = animateDataLib;
		function play(anitItemList, e) {
			var animatelist = translateLinetime(anitItemList, def_data)
			console.log('animate list', animatelist)

			driveAnimate(animatelist['animate'], animatelist['data'])
		}
	</script>

	<script>
		function u(time) {
			return time * 1000;
		}

		function _u(time) {
			return time / 1000;
		}
	</script>

	<script>

		function translateLinetime(aniItemList, aniDefData) {
			if (Array.isArray(aniItemList)) {
				if (aniItemList.length == 1) {
					//最简单的一个时

					let animatedata = aniDefData[aniItemList[0]['use_effect_id']].data;
					let finalAnimateData = {};

					for (const key_frame in animatedata) {
						if (Object.hasOwnProperty.call(animatedata, key_frame)) {
							const element = animatedata[key_frame];
							if (finalAnimateData[key_frame] == undefined) {
								finalAnimateData[key_frame] = {};
							}
							finalAnimateData[key_frame][aniItemList[0]['el']] = element;
						}
					}

					let animate = {
						data: aniItemList[0],
						animate: finalAnimateData
					}
					return animate;
				}

				// 多个，需要排列时间线

				let finalAnimateData = {};
				let timeLineEvent = {};
				let whole_time = 0;

				/**
				 * 时间线重组算法：根据每个特效的不同持续时间+延迟时间以及对应的百分比，
				 * 重新铺排唯一单条时间线
				 * 算法的逻辑：遍历所有特效参数以及对应的百分比关键帧数据，
				 * 记录什么时候执行这个帧数据，（受持续时间、延迟时间、循环次数影响）
				 */

				aniItemList.map(function (aItem, aIndex) {

					let animateData = aniDefData[aItem.use_effect_id].data;
					let el = aItem.el;

					if (animateData) {

						//先处理单次循环，后面再根据循环参数去补充完整时间线
						let one_loop_ani_item_time = u(aItem.delay + aItem.duration);

						for (const key_frame in animateData) {
							if (Object.hasOwnProperty.call(animateData, key_frame)) {
								const frame = animateData[key_frame];

								let current_key_frame_time = one_loop_ani_item_time * key_frame * 0.01 + u(aItem.delay);

								if (timeLineEvent[current_key_frame_time] == undefined) timeLineEvent[current_key_frame_time] = {};
								if (timeLineEvent[current_key_frame_time][el] == undefined) timeLineEvent[current_key_frame_time][el] = {};

								timeLineEvent[current_key_frame_time][el] = {
									...timeLineEvent[current_key_frame_time][el],
									...frame
								}

								//计算最大时间
								if (current_key_frame_time > whole_time) {
									whole_time = current_key_frame_time;
								}
							}
						}

					}


				})

				//避免出现第一个时不是0的情况
				if (timeLineEvent[0] == undefined) timeLineEvent[0] = {};

				//转成通用的百分比时间线
				for (const time_key in timeLineEvent) {
					if (Object.hasOwnProperty.call(timeLineEvent, time_key)) {
						const whole_frame_data = timeLineEvent[time_key];

						let current_percent = Number((Number(time_key) / whole_time * 100).toFixed(2));

						if (finalAnimateData[current_percent] == undefined) finalAnimateData[current_percent] = {};
						finalAnimateData[current_percent] = whole_frame_data;

					}
				}


				return {
					data: {
						duration: _u(whole_time),
						delay: 0,
						// FIXME: 考虑循环
						loop: 1,
						loopInterval: 0,
						fillMode: 'backwards'
					},
					animate: finalAnimateData
				};

			}
		}

	</script>



	<script>



		function driveAnimate(animate, params) {

			let el_queue = {};
			let current_time = params.delay ? u(params.delay) : 0;//单位 毫秒
			let all_time = 0;//动画总时长
			let fill_mode = params.fillMode;

			//计算动画总时长

			all_time = u(params.duration);

			var nextKeyFrame = function (key_frame) {
				let key_frame_array = Object.keys(animate);

				let res = null;
				for (let i = 0; i < key_frame_array.length; i++) {
					const current_key_frame = key_frame_array[i];
					if (current_key_frame == key_frame) {
						res = key_frame_array[i + 1];
						break;
					}

				}
				return res;

			}
			var lastKeyFrame = function (key_frame) {
				let key_frame_array = Object.keys(animate);

				let res = null;
				for (let i = 0; i < key_frame_array.length; i++) {
					const current_key_frame = key_frame_array[i];

					if (current_key_frame == key_frame) {
						if (i == 0) {
							res = null;
							break;
						} else {
							res = key_frame_array[i - 1];
							break;
						}

					}

				}
				return res;

			}

			//步进构建动画队列

			for (const key_frame in animate) {
				if (Object.hasOwnProperty.call(animate, key_frame)) {
					const element = animate[key_frame];//e.g:element={'target':{ "fontSize": "64px" }}

					for (const el in element) {
						if (Object.hasOwnProperty.call(element, el)) {
							const frame_data = element[el];//e.g:frame_data={ "fontSize": "64px" }
							let duration = 0;
							if (lastKeyFrame(key_frame)) {
								duration = (Number(key_frame) - lastKeyFrame(key_frame)) * 0.01 * all_time
							}

							//检测是否已经有el动画队列
							if (!el_queue[el]) {
								//第一次队列
								$("#" + el).velocity(frame_data, {
									delay: current_time,
									duration: duration,
									queue: el
								});
								el_queue[el] = $("#" + el);

							} else {
								el_queue[el].velocity(frame_data, {
									duration: duration,
									queue: el
								})
							}

							current_time += duration;

						}
					}


				}
			}

			// 执行 el 队列动画
			for (const el in el_queue) {
				if (Object.hasOwnProperty.call(el_queue, el)) {
					const eq = el_queue[el];
					if (fill_mode == 'backwards') {
						let frame_data = animate[0][el];
						eq.velocity({}, {
							delay: 0,
							duration: 0,
							complete: function (e) {

								for (const style in frame_data) {
									if (Object.hasOwnProperty.call(frame_data, style)) {
										const value = frame_data[style];
										e[0].style[style] = value;
									}
								}
							},
							queue: el
						});

					}

					eq.dequeue(el)
				}
			}

		}

	</script>


</body>

</html>